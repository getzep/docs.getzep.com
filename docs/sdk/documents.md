# Document Vector Store
:octicons-tag-24: **1.9.0-beta.0**

Zep's document vector store allows you to embed and search over documents using hybrid vector search. 

Collection management, document ingestion, and search may be done using either _Zep's Python SDK_ or _Langchain_. 

Most APIs below are also available for async use. See Zep's [Python SDK API](https://getzep.github.io/zep-python/zep_client/) for more.

Want to learn more about Collections, Documents, Embeddings and how Zep does vector search? 
Check out the [Key Concepts](#key-concepts) section.


!!! note "Zep Server v0.9.0-beta.0 or later required"
    
    The Zep Document Vector Store requires Zep Server v0.9.0-beta.0 or later.


## Initializing the Zep Client

Please see the [SDK documentation](/sdk) for more information on initializing the Zep client.

## Creating a Collection

```python
from zep_python import ZepClient
from zep_python.document import Document

client = ZepClient(base_url=zep_api_url, api_key="optional_api_key")

collection_name = "babbagedocs" # the name of your collection. alphanum values only

collection = client.document.add_collection(
    name=collection_name,  # required
    description="Charles Babbage's Babbage's Calculating Engine",  # optional
    metadata={"foo": "bar"},  # optional metadata to associate with this collection
    embedding_dimensions=384,  # this must match the model you've configured for 
    is_auto_embedded=True,  # use Zep's built-in embedder. Defaults to True
)
```

`embedding_dimensions` is the width of the vectors outputted by your embedding model. This must match the model you've configured for Zep to use when embedding texts. 
If you'd like to create the embedding vectors yourself and provide these to Zep, this value should match the width of the vectors generated by your model.

`is_auto_embedded` is indicates whether Zep should use its built-in embedder to generate embedding vectors for your documents. If you'd like to create the embedding vectors yourself and provide these to Zep, set this value to `False`.

## Adding Documents to a Collection

=== ":fontawesome-solid-robot: Zep SDK"

    ```python
    chunks = read_chunks_from_file(file, max_chunk_size)  # your custom function to read chunks from a file
    
    documents = [
        Document(
            content=chunk,
            document_id=f"{collection_name}-{i}",  # optional document ID
            metadata={"bar": i},  # optional metadata
        )
        for i, chunk in enumerate(chunks)
    ]
    
    uuids = collection.add_documents(documents)
    ```
    
    `document_id` is an optional ID for your document. You can use this to associate the document chunk of a document with
    your own identifier.
    
    `metadata` is an optional dictionary of metadata associated with your document. Zep offers hybrid search over a collectiom,
    where metadata can be used to filter search results.
    
    `collection.add_documents` returns a list of Zep UUIDs for the documents you've added to the collection.

=== ":parrot: :chains: Langchain"
    
    Zep's document vector store has experimental VectorStore support for Langchain. 

    While Zep's Memory and Retriever may be found in the Langchain codebase, Zep's VectorStore 
    is not yet available in Langchain itself. 

    Note the import path below is `zep_python.experimental.langchain`.

    ```python
    from langchain.docstore.base import Document
    from langchain.text_splitter import RecursiveCharacterTextSplitter
    from zep_python.experimental.langchain import ZepVectorStore

    vectorstore = ZepVectorStore(collection)

    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=400,
        chunk_overlap=50,
        length_function=len,
    )

    docs = text_splitter.create_documents([raw_text])
    uuids = vectorstore.add_documents(docs)
    ```

Your _chunking strategy_ will depend on your use case. There are a number of 3rd-party libraries, including Langchain, 
that support ingesting documents from a variety of sources and chunking them into smaller pieces for embedding.

## Monitoring Embedding Progress
Zep's document embedding process is asynchronous. You can monitor the state of your collection by polling the collection's status:

```python
while True:
    c = client.document.get_collection(collection_name)
    print(
        "Embedding status: "
        f"{c.document_embedded_count}/{c.document_count} documents embedded"
    )
    time.sleep(1)
    if c.status == "ready":
        break
```

When the collection's status is `ready`, all documents have been embedded and are ready for search.

## Searching a Collection using Hybrid Vector Search

Zep supports hybrid vector search over a collection. The most relevant documents are identified and ranked by semantic similarity and, optionally, filtered by matching on metadata associated with your documents. 

Either a text query or an embedding vector can be used to search a collection.

=== ":fontawesome-solid-robot: Zep SDK"

    ```python
    # search for documents using only a query string
    query = "the moon"
    results = collection.search(text=query, limit=5)
    
    # hybrid search for documents using a query string and metadata filter
    metadata_query = {
        "where": {"jsonpath": '$[*] ? (@.baz == "qux")'},
    }
    results = collection.search(text=query, metadata=metadata_query, limit=5)
    
    # Search by embedding vector, rather than text query
    # embedding is a list of floats
    results = collection.search(
        embedding=embedding, limit=5
    )
    ```
    
    `metadata` is an optional dictionary of [JSONPath filters](https://www.ietf.org/archive/id/draft-goessner-dispatch-jsonpath-00.html) used to match on metadata associated with your documents.
    
    `limit` is an optional integer indicating the maximum number of results to return.

=== ":parrot: :chains: Langchain"

    Zep's Langchain VectorStore may be used as a `Retriever` in a Langchain chain, allowing your chain to search over
    a Zep collection. 

    Both `similarity` and `mmr` search types are supported.

    ```python
    query = "What is Charles Babbage best known for?"

    print(f"\nSearching for '{query}'\n")
    results = vectorstore.search(query, search_type="similarity", k=5)
    print_results(results)

    print(f"\nSearching for '{query}' with MMR reranking\n")
    results = vectorstore.search(query, search_type="mmr", k=5)
    print_results(results)

    print(f"\Using Zep's VectorStore as a Retriever\n")
    chain = ConversationalRetrievalChain.from_llm(
        llm=llm,
        chain_type="stuff",
        retriever=vectorstore.as_retriever(),
        memory=memory,
        verbose=True,
    )
    ```

## Retrieving Documents by UUID

Zep supports retrieving a list of documents by Zep UUID:

```python
docs_to_get = uuids[40:50]
documents = collection.get_documents(docs_to_get)
```

## Indexing a Collection

By default, Zep performs exact _nearest neighbor search_ over a collection. Once a collection has a representative set of documents,
you can create an index to improve search performance. After an index is created, Zep will perform an _approximate nearest neighbor search_ over the collection.

By default, the floor on the number of documents required to create an index is 10,000. The `force` argument overrides the floor. This is useful for testing, but is
not recommended for production use as it may result in higher memory usage.

```python
collection.create_index(force=False)  # Do not use force unless testing!
```

## Other Common Operations

### List all Collections

```python
collections = client.document.list_collections()
```

### Updating a Collection's Description or Metadata

```python
client.document.update_collection(
    collection_name,
    description="Charles Babbage's Babbage's Calculating Engine 2",
    metadata={"newfoo": "newbar"},
)
```

### Update a Document's ID or Metadata

```python
collection.update_document(document_uuid, document_id="new_id", metadata={"foo": "bar"})
```

### Deleting Documents

Zep supports deleting documents from a collection by UUID:

```python
collection.delete_document(document_uuid)
```

### Deleting a Collection

Deleting a collection will delete all documents in the collection, as well as the collection itself.

```python
client.document.delete_collection(collection_name)
```


## Key Concepts

### Collections

A collection is a set of documents that share a common embedding strategy and embedding model. **Zep automatically creates embeddings** from the documents you provide it, or **you can provide the embeddings** when you add your documents to a collection. All documents in a collection must have been embedded using the same model.

### Documents

Documents are the texts that you want to embed and search over. Documents are added to collections. Documents may have a unique ID and metadata associated with them. **If metadata is added, you can use it to filter search results.**

### Embeddings

Embeddings are vectors that represent the semantic meaning of a document. Zep stores both the text and embedding for each document, and uses the embedding to perform semantic search.

Zep can be configured to use, or you can provide, either normalized or unnormalized embeddings.

### Search and Search Scores

Zep supports two types of search: **semantic search** and **hybrid search**. Semantic search uses the document embeddings to find documents that are semantically similar to a query. Hybrid search uses both the document embeddings and metadata to find documents that are semantically similar to a query and match the metadata filters.

You can provide either a text query or an embedding vector when performing a search. If you provide a text query, Zep will embed the query text using the same model that was used to embed the documents in the collection. If you provide an embedding vector, Zep will use that vector directly.

Zep scores search results using **cosine distance** and then **normalizes this distance to a value between 0 and 1**, where 1 is a perfect match. The score is returned as part of the search results.